/**
 * Remove Auto-Generated $description Tokens
 * Purpose: Clean up Copilot/AI generated descriptions from token files
 * Date: September 18, 2025
 */

const fs = require('fs');
const path = require('path');

async function removeAutoGeneratedDescriptions() {
    console.log('ðŸ” SCANNING FOR AUTO-GENERATED $DESCRIPTION TOKENS');
    console.log('=================================================');
    
    const themesPath = '/Users/davorradisic/vc git repo bit/oblique/projects/design-system/src/lib/themes';
    let totalDescriptions = 0;
    let removedDescriptions = 0;
    const modifiedFiles = [];
    
    // Common patterns that indicate auto-generated descriptions
    const AUTO_GENERATED_PATTERNS = [
        /^Static (color|value|token)/i,
        /^CSS implementation of/i,
        /^\d+px - /i,  // "4px - Small spacing"
        /^\d+px equivalent/i,  // "4px equivalent - Small spacing"
        /References primitive/i,
        /Zero size for hidden elements/i,
        /Finest details, hairlines/i,
        /Subtle adjustments/i,
        /Standard component internal/i,
        /Large component internal/i,
        /Medium surface padding/i,
        /Small surface padding/i,
        /Large surface padding/i,
        /Small container padding/i
    ];
    
    // Function to check if description seems auto-generated
    function isAutoGenerated(description) {
        if (!description || typeof description !== 'string') return false;
        
        return AUTO_GENERATED_PATTERNS.some(pattern => pattern.test(description.trim()));
    }
    
    // Recursive function to clean descriptions from token objects
    function cleanDescriptions(obj, filePath) {
        let fileModified = false;
        
        for (const key in obj) {
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                if (key === '$description') {
                    totalDescriptions++;
                    
                    if (isAutoGenerated(obj[key])) {
                        console.log(`  Removing: "${obj[key]}" from ${filePath}`);
                        delete obj[key];
                        removedDescriptions++;
                        fileModified = true;
                    }
                } else {
                    const childModified = cleanDescriptions(obj[key], filePath);
                    if (childModified) fileModified = true;
                }
            }
        }
        
        return fileModified;
    }
    
    // Function to process a single file
    function processFile(filePath) {
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const jsonData = JSON.parse(content);
            
            const fileModified = cleanDescriptions(jsonData, path.relative(themesPath, filePath));
            
            if (fileModified) {
                // Write back with pretty formatting
                fs.writeFileSync(filePath, JSON.stringify(jsonData, null, 2));
                modifiedFiles.push(path.relative(themesPath, filePath));
                console.log(`âœ… Cleaned: ${path.relative(themesPath, filePath)}`);
            }
            
        } catch (error) {
            console.error(`âŒ Error processing ${filePath}: ${error.message}`);
        }
    }
    
    // Recursive function to scan directories
    function scanDirectory(dirPath) {
        const items = fs.readdirSync(dirPath, { withFileTypes: true });
        
        for (const item of items) {
            const fullPath = path.join(dirPath, item.name);
            
            if (item.isDirectory()) {
                scanDirectory(fullPath);
            } else if (item.name.endsWith('.json')) {
                console.log(`\nðŸ“„ Processing: ${path.relative(themesPath, fullPath)}`);
                processFile(fullPath);
            }
        }
    }
    
    // Start scanning
    scanDirectory(themesPath);
    
    // Generate summary report
    console.log('\n' + '='.repeat(60));
    console.log('ðŸ“Š CLEANUP SUMMARY');
    console.log('='.repeat(60));
    console.log(`Total $description tokens found: ${totalDescriptions}`);
    console.log(`Auto-generated descriptions removed: ${removedDescriptions}`);
    console.log(`Manual descriptions preserved: ${totalDescriptions - removedDescriptions}`);
    console.log(`Files modified: ${modifiedFiles.length}`);
    
    if (modifiedFiles.length > 0) {
        console.log('\nðŸ“ Modified files:');
        modifiedFiles.forEach(file => {
            console.log(`   â€¢ ${file}`);
        });
    }
    
    console.log(`\nðŸ’¡ Reduction: ${Math.round((removedDescriptions / totalDescriptions) * 100)}% of descriptions removed`);
    
    return {
        totalDescriptions,
        removedDescriptions,
        modifiedFiles
    };
}

// Command line interface
if (require.main === module) {
    const args = process.argv.slice(2);
    
    if (args.includes('--help')) {
        console.log(`
ðŸ”§ Remove Auto-Generated $description Tokens

Usage:
  node remove-auto-descriptions.js                    # Run the cleanup
  node remove-auto-descriptions.js --help             # Show this help

This script identifies and removes auto-generated descriptions that match common patterns:
- "Static color to be used..."
- "CSS implementation of..."  
- "4px - Small spacing..."
- "References primitive..."
- And other AI/Copilot generated patterns

Manual, meaningful descriptions are preserved.
        `);
    } else {
        removeAutoGeneratedDescriptions().catch(console.error);
    }
}

module.exports = { removeAutoGeneratedDescriptions };
